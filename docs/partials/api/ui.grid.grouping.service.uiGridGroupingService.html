<h1><code ng:non-bindable="">uiGridGroupingService</code>
<span class="hint">(service in module <code ng:non-bindable="">ui.grid.grouping</code>
)</span>
</h1>
<div><h2 id="Description">Description</h2>
<div class="description"><p>Services for grouping features</p></div>
<div class="member method"><h2 id="Methods">Methods</h2>
<ul class="methods"><li><h3 id="aggregate">aggregate(grid, row, parents)</h3>
<div class="aggregate"><p>Accumulate the data from this row onto the aggregations for each parent</p>

<p>Iterate over the parents, then iterate over the aggregations for each of those parents,
and perform the aggregation for each individual aggregation</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">row – {GridRow} – </code>
<p>the row we want to set grouping visibility on</p></li>
<li><code ng:non-bindable="">parents – {array} – </code>
<p>the parents that we would want to aggregate onto</p></li>
</ul>
</div>
</li>
<li><h3 id="aggregateColumn">aggregateColumn(grid, column, aggregationType)</h3>
<div class="aggregatecolumn"><p>Sets the aggregation type on a column, if the 
column is currently grouped then it removes the grouping first.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">column – {GridCol} – </code>
<p>the column we want to aggregate</p></li>
<li><code ng:non-bindable="">aggregationType – {string} – </code>
<p>one of the recognised types
from uiGridGroupingConstants</p></li>
</ul>
</div>
</li>
<li><h3 id="applyRowExpandedStates">applyRowExpandedStates(currentNode)</h3>
<div class="applyrowexpandedstates"><p>Take a hash in the format as created by getRowExpandedStates,
and apply it to the grid.grouping.groupHeaderCache.</p>

<p>Takes a treeSubset, and applies to a treeSubset - so can be called
recursively.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">currentNode – {object} – </code>
<p>can be grid.grouping.groupHeaderCache, or any of
the children of that hash</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{hash}</code>
– <p>expandedStates can be the full expanded states, or children
of that expanded states (which hopefully matches the subset of the groupHeaderCache)</p></div>
</div>
</li>
<li><h3 id="clearGrouping">clearGrouping(grid)</h3>
<div class="cleargrouping"><p>Clear any grouped columns and any aggregations.  Doesn't remove sorting,
as we don't know whether that sorting was added by grouping or was there beforehand</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
</ul>
</div>
</li>
<li><h3 id="finaliseAggregations">finaliseAggregations(row)</h3>
<div class="finaliseaggregations"><p>Format the data from the aggregation into the rendered text
e.g. if we had label: 'sum: ' and value: 25, we'd create 'sum: 25'.</p>

<p>As part of this we call any formatting callback routines we've been provided.</p>

<p>We write our aggregation out to the row.entity if treeAggregationUpdateEntity is
set on the column - we don't overwrite any information that's already there, we append
to it so that grouping can have set the groupVal beforehand without us overwriting it.</p>

<p>We need to copy the data from the row.entity first before we finalise the aggregation,
we need that information for the finaliserFn</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">row – {gridRow} – </code>
<p>the parent we're finalising</p></li>
</ul>
</div>
</li>
<li><h3 id="finaliseProcessingState">finaliseProcessingState(grid, processingState, stateIndex)</h3>
<div class="finaliseprocessingstate"><p>Set all processing states lower than the one that had a break in value to
no longer be initialised.  Render the counts into the entity ready for display.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">processingState – {array} – </code>
<p>the current processing state</p></li>
<li><code ng:non-bindable="">stateIndex – {number} – </code>
<p>the processing state item that we were on when we triggered a new group header, all
processing states after this need to be finalised</p></li>
</ul>
</div>
</li>
<li><h3 id="getGrouping">getGrouping(grid)</h3>
<div class="getgrouping"><p>Get the grouping settings from the columns.  As a side effect
this always renumbers the grouping starting at 0</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{array}</code>
– <p>an array of the group fields, in order of priority</p></div>
</div>
</li>
<li><h3 id="getRowExpandedStates">getRowExpandedStates(grid)</h3>
<div class="getrowexpandedstates"><p>Extract the groupHeaderCache hash, pulling out only the states.</p>

<p>The example below shows a grid that is grouped by gender then age</p>

<pre class="prettyprint linenums">
  {
    male: {
      state: 'expanded',
      children: {
        22: { state: 'expanded' },
        30: { state: 'collapsed' }
      }
    },
    female: {
      state: 'expanded',
      children: {
        28: { state: 'expanded' },
        55: { state: 'collapsed' }
      }
    }
  }
</pre><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{hash}</code>
– <p>the expanded states as a hash</p></div>
</div>
</li>
<li><h3 id="groupColumn">groupColumn(grid, column)</h3>
<div class="groupcolumn"><p>Adds this column to the existing grouping, at the end of the priority order.
If the column doesn't have a sort, adds one, by default ASC</p>

<p>This column will move to the left of any non-group columns, the
move is handled in a columnProcessor, so gets called as part of refresh</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">column – {GridCol} – </code>
<p>the column we want to group</p></li>
</ul>
</div>
</li>
<li><h3 id="groupRows">groupRows(renderableRows)</h3>
<div class="grouprows"><p>The rowProcessor that creates the groupHeaders (i.e. does
the actual grouping).</p>

<p>Assumes it is always called after the sorting processor, guaranteed by teh priority setting</p>

<p>Processes all the rows in order, inserting a groupHeader row whenever there is a change
in value of a grouped row.  The group header row is looked up in the groupHeaderCache, and used
from there if there is one.  The entity is reset to {} if one is found.</p>

<p>As it processes it maintains a <code>processingState</code> array. This records, for each level of grouping we're
working with, the following information:</p>

<pre><code>  {
    fieldName: name,
    col: col,
    initialised: boolean,
    currentValue: value,
    currentRow: gridRow,
  }
</code></pre>

<p>We look for changes in the currentValue at any of the levels.  Where we find a change we:</p>

<ul>
<li>create a new groupHeader row in the array</li>
</ul><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">renderableRows – {array} – </code>
<p>the rows we want to process, usually the output from the previous rowProcessor</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{array}</code>
– <p>the updated rows, including our new group rows</p></div>
</div>
</li>
<li><h3 id="groupingColumnBuilder">groupingColumnBuilder(colDef, col, gridOptions)</h3>
<div class="groupingcolumnbuilder"><p>Sets the grouping defaults based on the columnDefs</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">colDef – {object} – </code>
<p>columnDef we're basing on</p></li>
<li><code ng:non-bindable="">col – {GridCol} – </code>
<p>the column we're to update</p></li>
<li><code ng:non-bindable="">gridOptions – {object} – </code>
<p>the options we should use</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise for the builder - actually we do it all inline so it's immediately resolved</p></div>
</div>
</li>
<li><h3 id="groupingColumnProcessor">groupingColumnProcessor(columns, rows)</h3>
<div class="groupingcolumnprocessor"><p>Moves the columns around based on which are grouped</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">columns – {array} – </code>
<p>the columns to consider rendering</p></li>
<li><code ng:non-bindable="">rows – {array} – </code>
<p>the grid rows, which we don't use but are passed to us </p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{array}</code>
– <p>updated columns array</p></div>
</div>
</li>
<li><h3 id="initialiseProcessingState">initialiseProcessingState(grid)</h3>
<div class="initialiseprocessingstate"><p>Creates the processing state array that is used
for groupRows.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{array}</code>
– <p>an array in the format described in the groupRows method, 
initialised with blank values</p></div>
</div>
</li>
<li><h3 id="insertGroupHeader">insertGroupHeader(grid, renderableRows, rowIndex, processingState, stateIndex)</h3>
<div class="insertgroupheader"><p>Create a group header row, and link it to the various configuration
items that we use.</p>

<p>Look for the row in the oldGroupingHeaderCache, write the row into the new groupingHeaderCache.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">renderableRows – {array} – </code>
<p>the rows that we are processing</p></li>
<li><code ng:non-bindable="">rowIndex – {number} – </code>
<p>the row we were up to processing</p></li>
<li><code ng:non-bindable="">processingState – {array} – </code>
<p>the current processing state</p></li>
<li><code ng:non-bindable="">stateIndex – {number} – </code>
<p>the processing state item that we were on when we triggered a new group header - 
i.e. the column that we want to create a header for</p></li>
</ul>
</div>
</li>
<li><h3 id="moveGroupColumns">moveGroupColumns(grid, columns, rows)</h3>
<div class="movegroupcolumns"><p>Moves the column order so that the grouped columns are lined up
to the left (well, unless you're RTL, then it's the right).  By doing this in 
the columnsProcessor, we make it transient - when the column is ungrouped it'll
go back to where it was.</p>

<p>Does nothing if the option <code>moveGroupColumns</code> is set to false.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">columns – {array} – </code>
<p>the columns that we should process/move</p></li>
<li><code ng:non-bindable="">rows – {array} – </code>
<p>the grid rows</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{array}</code>
– <p>updated columns</p></div>
</div>
</li>
<li><h3 id="setGrouping">setGrouping(grid, config)</h3>
<div class="setgrouping"><p>Set the grouping based on a config object, used by the save state feature 
(more specifically, by the restore function in that feature )</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">config – {object} – </code>
<p>the config we want to set, same format as that returned by getGrouping</p></li>
</ul>
</div>
</li>
<li><h3 id="tidyPriorities">tidyPriorities(grid)</h3>
<div class="tidypriorities"><p>Renumbers groupPriority and sortPriority such that
groupPriority is contiguous, and sortPriority either matches
groupPriority (for group columns), and otherwise is contiguous and 
higher than groupPriority. </p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
</ul>
</div>
</li>
<li><h3 id="ungroupColumn">ungroupColumn(grid, column)</h3>
<div class="ungroupcolumn"><p>Removes the groupPriority from this column.  If the
column was previously aggregated the aggregation will come back. 
The sort will remain.  </p>

<p>This column will move to the right of any other group columns, the
move is handled in a columnProcessor, so gets called as part of refresh</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>grid object</p></li>
<li><code ng:non-bindable="">column – {GridCol} – </code>
<p>the column we want to ungroup</p></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
